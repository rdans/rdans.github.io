



# CS 168 Computational Methods for Medical Imaging 

**Automatic Lung's Grade Image Classification from CT**
by Reinaldo Daniswara and Tianyang Zhang

## Preprocessing
This week, we finish the preprocessing image, which takes the whole week to do some trial and errors until the image is successfully generated. 

We are doing this preprocessing using jupyter notebook and a couple build-in library and packages, such as numpy, maplotplib, dicom, os, os.path, scipy.ndimage, and pandas.

For the whole CT scan images, the total size of the image is around 66 GB and to do the image preprocessing itself, requires a lot of time to finish it all. However, in term of testing we used a smaller dataset, which have a size around 1.8 GB.  Images below are the result of the preprocessing and lung segmentation. Code and algorithm will discuss below.

<figure>
<img align="center" width="500" height="300" src="https://drive.google.com/uc?id=1cATIJd3srO1SsnjbcSsSNkhNaOlEOrYl" alt="Please Open in Chrome">
<figcaption>Figure 1. Description from top left to the top right, and then below left to below right. Original image, after pixel adjustment, Internal Marker, External Marker, Watershed Marker, Gradient Image, Segmented images with border, final result after normalization and zero centering</figcaption>
</figure>

First, due to the amount of noise that generated by the radiation of CT scan, it is hard to determine the nodule or just a regular air. Thus, before we could use the data to train the model, we need to do some image processing technique, to remove redundancy across all images, since not all of the images in the whole dataset have the same format.

Load the data:
```python
def read_data(patient_dir):
    patient_img = []
    for dcmfile in os.listdir(patient_dir):
        patient_img.append(dicom.read_file(patient_dir + '/' + dcmfile, force=True))
        patient_img
    patient_img.sort(key = lambda slice: float(slice.ImagePositionPatient[2]))
    return patient_img
    
data_folder = '/Users/reinaldodaniswara/Desktop/cs168/project/code/patient_folder/data_folder/sample_images'
patients = os.listdir(data_folder)
num = len(patients)
slash = []
for i in range(0,num):
    a = "/"
    slash.append(a)
    slash
patients = [m+str(n) for m,n in zip(slash,patients)]
patients = patients[1:]
print(patients)
```

Below is the code for the pixel adjustment.

```python
def hu_array(patient_img):
    n_x = patient_img[0].Rows
    n_y = patient_img[0].Columns
    n_z = len(patient_img)
    hu_array = np.zeros((n_x, n_y, n_z), dtype=np.float32)
    for slice_indices in range(len(patient_img)):
        intercept = patient_img[slice_indices].RescaleIntercept
        slope = patient_img[slice_indices].RescaleSlope
        px_arr = patient_img[slice_indices].px_arr
        px_arr[px_arr == -2000] = 0
        hu_array[:,:,slice_indices] = (slope * px_arr) + intercept
        
    return hu_array.astype(np.int16)

hu_array_sample = hu_array(patient_img_sample)

def resample_data(patient_img, new_spacings):
    original_z_spacing = np.abs(patient_img[0].ImagePositionPatient[2]
                                - patient_img[1].ImagePositionPatient[2])
    hu_array = hu_array(patient_img)
    
    original_spacings = np.array(patient_img[0].PixelSpacing + [original_z_spacing], dtype='float32')
    shape = hu_array.shape
    new_shape = np.round(hu_array.shape * original_spacings / new_spacings)
    zoom_factor = new_shape / hu_array.shape
    
    return scipy.ndimage.interpolation.zoom(hu_array, zoom_factor, mode='nearest')

new_spacings = [1, 1, 1] 
resampled_patient_img_sample = resample_data(patient_img_sample, new_spacings)
plt.imshow(resampled_patient_img_sample[:,:,100], cmap=plt.cm.bone)
plt.show()
```

Below is the code for the Watershed
```python
def watershed_func(data):
    # create internal markers
    internal_marker = data < -400
    for s in range(data.shape[2]):
        internal_marker[:,:,s] = segmentation.clear_border(internal_marker[:,:,s])
    internal_marker_labels = measure.label(internal_marker)
    potential_lung_regions = measure.regionprops(internal_marker_labels)
    potential_lung_regions.sort(key = lambda region: region.area)

    for region in potential_lung_regions[:-1]:
        coords_tuple = tuple([tuple(coord) for coord in region.coords.transpose()])
        internal_marker_labels[coords_tuple] = 0
    internal_marker = internal_marker_labels > 0

    # create external markers
    external_in_marker = scipy.ndimage.binary_dilation(internal_marker, iterations=8)
    external_out_marker = scipy.ndimage.binary_dilation(internal_marker, iterations=35)
    external_marker = external_out_marker ^ external_in_marker
    
    # create watershed markers 
    watershed_marker = internal_marker.astype(np.int16) * 2 + external_marker.astype(np.int16) * 1
    
    return internal_marker, external_marker, watershed_marker

internal_marker, external_marker, watershed_marker = watershed_func(resampled_patient_img_sample)
```

Below is the code to generate the sober filter using gradient images.
```python
def slice_lung_segmentation(slice, internal_marker, watershed_marker):
    # find edges with Sober filters
    sober_x = scipy.ndimage.sobel(slice, axis=0)
    sober_y = scipy.ndimage.sobel(slice, axis=1)
    sober = np.hypot(sober_x, sober_y)

    # apply watershed algorithm to find watershed basins flooded from the markers
    watershed = morphology.watershed(sober, watershed_marker)
    
    # outline of watershed
    border = scipy.ndimage.morphological_gradient(watershed, size=(3,3)).astype(bool)
    
    # apply black tophat filter to include possible nodules near the lung border
    black_tophat = [[0, 0, 1, 1, 1, 0, 0],
                    [0, 1, 1, 1, 1, 1, 0],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [0, 1, 1, 1, 1, 1, 0],
                    [0, 0, 1, 1, 1, 0, 0]]
    black_tophat = scipy.ndimage.iterate_structure(black_tophat, 5)
    border += scipy.ndimage.black_tophat(border, structure=black_tophat)
    
    # combine the lung and the regions near its border which may contain nodules
    lung = np.bitwise_or(internal_marker, border)
    # remove the small air pockets inside the lung

    lung = scipy.ndimage.binary_fill_holes(lung)
    
    return lung, sober, watershed, border

internal_marker, external_marker, watershed_marker = watershed_func(resampled_patient_img_sample)

sample_slice_indices = 99
sample_slice = resampled_patient_img_sample[:,:,sample_slice_indices]
lung, sober, watershed, border = slice_lung_segmentation(
    sample_slice,
    internal_marker[:,:,sample_slice_indices],
    watershed_marker[:,:,sample_slice_indices],
    )
```

Lung segmentation, reshaped, normalized, and zero centering
```python
def lung_segmentation(data):
    segmented_lung = np.ones(data.shape) * 30
    segmented_internal_marker = np.zeros(data.shape)
    
    internal_marker, external_marker, watershed_marker = watershed_func(data)
    
    for slice_indices in range(data.shape[2]):
        slice_marker,_,_,_ = slice_lung_segmentation(data[:,:,slice_indices],
                                                     internal_marker[:,:,slice_indices],
                                                     watershed_marker[:,:,slice_indices])
        segmented_internal_marker[:,:,slice_indices] = slice_marker
    segmented_lung[segmented_internal_marker.astype(bool)] = data[segmented_internal_marker.astype(bool)]

    for x_zero in range(data.shape[0]):
        slice = segmented_internal_marker[x_zero,:,:]
        if not np.array_equal(slice, np.zeros(slice.shape)): break
    for x_end in range(-1,-data.shape[0]-1,-1):
        slice = segmented_internal_marker[x_end,:,:]
        if not np.array_equal(slice, np.zeros(slice.shape)): break
    for y_zero in range(data.shape[1]):
        slice = segmented_internal_marker[:,y_zero,:]
        if not np.array_equal(slice, np.zeros(slice.shape)): break
    for y_end in range(-1,-data.shape[1]-1,-1):
        slice = segmented_internal_marker[:,y_end,:]
        if not np.array_equal(slice, np.zeros(slice.shape)): break
    for z_zero in range(data.shape[2]):
        slice = segmented_internal_marker[:,:,z_zero]
        if not np.array_equal(slice, np.zeros(slice.shape)): break
    for z_end in range(-1,-data.shape[2]-1,-1):
        slice = segmented_internal_marker[:,:,z_end]
        if not np.array_equal(slice, np.zeros(slice.shape)): break

    if x_end == -1: x_end = -2
    if y_end == -1: y_end = -2
    if z_end == -1: z_end = -2

    return segmented_lung[x_zero:(x_end+1),y_zero:(y_end+1),z_zero:(z_end+1)]

segmented_lung_sample = lung_segmentation(resampled_patient_img_sample)
#plt.imshow(segmented_lung_sample[:,:,63], cmap=plt.cm.bone)
#plt.show()

def reshape_data(segmented_lung, desired_shape):
    shape = list(segmented_lung.shape)
    differences = np.array(desired_shape) - np.array(shape)
    padding = []
    for i in range(3):
        before = (abs(differences[i])/2).astype(np.int16)
        after = abs(differences[i]) - before
        if differences[i] < 0:
        	padding.append((0,0))
            if i == 0: segmented_lung = segmented_lung[before:(-after),:,:]
            if i == 1: segmented_lung = segmented_lung[:,before:(-after),:]
            if i == 2: segmented_lung = segmented_lung[:,:,abs(differences[i]):]
        else:
            padding.append((before, after))
                
            print('Trimmed data for axis ' + str(i))

    reshaped_data = np.lib.pad(segmented_lung, tuple(padding), 'constant', constant_values=30)
    assert (list(reshaped_data.shape) == desired_shape), \
        'Original shape of the data is (%s, %s, %s), desired shape is (%s, %s, %s)' \
        % (reshaped_data.shape[0], reshaped_data.shape[1], reshaped_data.shape[2], \
        desired_shape[0], desired_shape[1], desired_shape[2])
    
    return reshaped_data

desired_shape = [250, 350, 400]
reshaped_sample = reshape_data(segmented_lung_sample, desired_shape)

# to reduce the image noise
def normalize_data(reshaped_data, min_huval, max_huval):
    normalized_data = (reshaped_data - min_huval) / (max_huval - min_huval)
    normalized_data[normalized_data < 0.] = 0.
    normalized_data[normalized_data > 1.] = 1.
    return normalized_data
    
air_hu = -1000.
bone_hu = 400.

normalized_sample = normalize_data(reshaped_sample, air_hu, bone_hu)

def zero_centering(data, mean):
    return data - mean

mean = 0.3
preprocessed_sample = zero_centering(normalized_sample, mean)
#plt.imshow(preprocessed_sample[:,:,114], cmap=plt.cm.bone)
#plt.show()

labels = pd.read_csv('/Users/reinaldodaniswara/Desktop/cs168/project/code/patient_folder/data_folder/stage1_labels.csv')

save_data_folder = '/Users/reinaldodaniswara/Desktop/cs168/project/code/patient_folder/data_folder/sample_images_preprocessed/'

for patient in patients:
    if (os.path.exists(save_data_folder + patient + '.npz')):
        print('Patient: ' + patient + ' (data existed)')
        continue
    patient_img = read_data(data_folder + patient)
    resampled_patient_img = resample_data(patient_img, new_spacings)
    segmented_lung = lung_segmentation(resampled_patient_img)
    reshaped_patient_img = reshape_data(segmented_lung, desired_shape)
    normalized_patient_img = normalize_data(reshaped_patient_img, air_hu, bone_hu)
    preprocessed_patient_img = zero_centering(normalized_patient_img, mean)
    
    # reading the label
    patient_label = labels[labels['id'] == patient]
    
    # save preprocessed data to a .npz file
    if patient_label.shape[0] == 1: # training set
        np.savez_compressed(save_data_folder + patient,
                            id = patient,
                            data = preprocessed_patient_img,
                            label = patient_label.iloc[0,1],
                            set = 'training')
    else: # test set
        np.savez_compressed(save_data_folder + patient,
                            id = patient,
                            data = preprocessed_patient_img,
                            set = 'test')    
    
    print('Patient: ' + patient)
    print('Resampled shape: ({:3d},{:3d},{:3d}) \
        Segmented shape: ({:3d},{:3d},{:3d}) \
        Final shape: ({:3d},{:3d},{:3d})'.format(
        resampled_patient_img.shape[0],
        resampled_patient_img.shape[1],
        resampled_patient_img.shape[2],
        segmented_lung.shape[0],
        segmented_lung.shape[1],
        segmented_lung.shape[2],
        preprocessed_patient_img.shape[0],
        preprocessed_patient_img.shape[1],
        preprocessed_patient_img.shape[2],))
print('Finish Preprocessing')
```
[<< Go back to the weekly progress page](http://reinaldodaniswara.com/medicalimaging.html) || [Go to 3D CNN code >>](http://reinaldodaniswara.com/cnn.html)
